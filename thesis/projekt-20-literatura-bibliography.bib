@book{meduna_book,
publisher = {Springer},
isbn = {9781852330743},
year = {2012},
title = {Automata and languages: theory and applications},
language = {eng},
author = {Meduna, Alexander},
keywords = {Formal languages}
}

@article{buchi_ws1s_fa,
author = {Büchi, J. Richard},
title = {Weak Second-Order Arithmetic and Finite Automata},
journal = {Mathematical Logic Quarterly},
volume = {6},
number = {1-6},
pages = {66-92},
doi = {https://doi.org/10.1002/malq.19600060105},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/malq.19600060105},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/malq.19600060105},
year = {1960}
}

@article{elgot_ws1s_fa,
ISSN = {00029947},
URL = {http://www.jstor.org/stable/1993511},
author = {Calvin C. Elgot},
journal = {Transactions of the American Mathematical Society},
number = {1},
pages = {21--51},
publisher = {American Mathematical Society},
title = {Decision Problems of Finite Automata Design and Related Arithmetics},
urldate = {2022-11-17},
volume = {98},
year = {1961}
}

@InProceedings{meyer_ws1s_complexity,
author="Meyer, Albert R.",
editor="Parikh, Rohit",
title="Weak monadic second order theory of succesor is not elementary-recursive",
booktitle="Logic Colloquium",
year="1975",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="132--154",
isbn="978-3-540-37483-1"
}

@Article{mona_impl_sec,
  author =       {Nils Klarlund and Anders M\o{}ller and Michael I. Schwartzbach},
  title =        {{MONA} Implementation Secrets},
  journal =      {International Journal of Foundations of Computer Science},
  year =         {2002},
  volume =       {13},
  number =       {4},
  pages =        {571--586},
  note =         {World Scientific Publishing Company.
                  Earlier version in Proc. 5th International Conference 
                  on Implementation and Application of Automata, CIAA~'00, 
                  Springer-Verlag LNCS vol.\ 2088},
}

@InProceedings{mona_restrictions,
  author = {Nils Klarlund},
  title = {A theory of restrictions for logics and automata},
  booktitle = {Computer Aided Verification, CAV '99},
  series = {LNCS},
  volume= {1633}
}

@InProceedings{mona_new_tech,
  author =       {Jacob Elgaard and Nils Klarlund and Anders M{\o}ller},
  title =        {{MONA} 1.x: new techniques for {WS1S} and {WS2S}},
  booktitle =    {Proc. 10th International Conference on 
                  Computer-Aided Verification, CAV~'98},
  year =         {1998},
  month =        {June/July},
  volume =       {1427},
  series =       {LNCS},
  publisher =    {Springer-Verlag},
  pages =        {516--520},
}

@INPROCEEDINGS{mona_log_aut_conn,
	AUTHOR = {Klarlund, Nils},
	TITLE = {Mona \& Fido: The Logic-Automaton Connection
in Practice},
	BOOKTITLE = {Computer Science Logic, CSL '97},
	YEAR = {1998},
        SERIES = {LNCS},
        NOTE= {LNCS 1414},
}

@Manual{mona_manual,
  author =       {Nils Klarlund and Anders M{\o}ller},
  title =        {{MONA Version 1.4 User Manual}},
  organization = {BRICS, Department of Computer Science, University of Aarhus},
  month =        {January},
  year =         {2001},
  note =         {Notes Series NS-01-1.
                  Available from \texttt{\small http://www.brics.dk/mona/}}
}

@InProceedings{fiedor_ws1s,
author="Fiedor, Tom{\'a}{\v{s}}
and Hol{\'i}k, Luk{\'a}{\v{s}}
and Jank{\r{u}}, Petr
and Leng{\'a}l, Ond{\v{r}}ej
and Vojnar, Tom{\'a}{\v{s}}",
editor="Legay, Axel
and Margaria, Tiziana",
title="Lazy Automata Techniques for WS1S",
booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
year="2017",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="407--425"
}

@inproceedings{verifit_wsks,
  author    = {Vojtěch Havlena and Lukáš Holík and Ondřej Lengál and Ondřej Valeš and Tomáš Vojnar},
  title     = {Antiprenexing for WSkS: A Little Goes a Long Way},
  booktitle = {LPAR23. LPAR-23: 23rd International Conference on Logic for Programming, Artificial Intelligence and Reasoning},
  editor    = {Elvira Albert and Laura Kovacs},
  series    = {EPiC Series in Computing},
  volume    = {73},
  pages     = {298--316},
  year      = {2020},
  publisher = {EasyChair},
  bibsource = {EasyChair, https://easychair.org},
  issn      = {2398-7340},
  url       = {https://easychair.org/publications/paper/4JDl},
  doi       = {10.29007/6bfc}}


@inproceedings{intro_ver_app1,
author = {M\o{}ller, Anders and Schwartzbach, Michael I.},
title = {The Pointer Assertion Logic Engine},
year = {2001},
isbn = {1581134142},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/378795.378851},
doi = {10.1145/378795.378851},
abstract = {We present a new framework for verifying partial specifications of programs in order to catch type and memory errors and check data structure invariants. Our technique can verify a large class of data structures, namely all those that can be expressed as graph types. Earlier versions were restricted to simple special cases such as lists or trees. Even so, our current implementation is as fast as the previous specialized tools.Programs are annotated with partial specifications expressed in Pointer Assertion Logic, a new notation for expressing properties of the program store. We work in the logical tradition by encoding the programs and partial specifications as formulas in monadic second-order logic. Validity of these formulas is checked by the MONA tool, which also can provide explicit counterexamples to invalid formulas.To make verification decidable, the technique requires explicit loop and function call invariants. In return, the technique is highly modular: every statement of a given program is analyzed only once.The main target applications are safety-critical data-type algorithms, where the cost of annotating a program with invariants is justified by the value of being able to automatically verify complex properties of the program.},
booktitle = {Proceedings of the ACM SIGPLAN 2001 Conference on Programming Language Design and Implementation},
pages = {221–231},
numpages = {11},
location = {Snowbird, Utah, USA},
series = {PLDI '01}
}


@article{intro_ver_app2,
author = {Madhusudan, P. and Parlato, Gennaro and Qiu, Xiaokang},
title = {Decidable Logics Combining Heap Structures and Data},
year = {2011},
issue_date = {January 2011},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {46},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/1925844.1926455},
doi = {10.1145/1925844.1926455},
abstract = {We define a new logic, STRAND, that allows reasoning with heap-manipulating programs using deductive verification and SMT solvers. STRAND logic ("STRucture ANd Data" logic) formulas express constraints involving heap structures and the data they contain; they are defined over a class of pointer-structures R defined using MSO-defined relations over trees, and are of the form ∃→x∀→y (→x,→) x" , where "φ" is a monadic second-order logic (MSO) formulawith additional quantification that combines structural constraints as well as data-constraints, but where the data-constraints are only allowed to refer to "→x" and "→y"The salient aspects of the logic are: (a) the logic is powerful, allowing existential and universal quantification over the nodes, and complex combinations of data and structural constraints; (b) checking Hoare-triples for linear blocks of statements with pre-conditions and post-conditions expressed as Boolean combinations of existential and universal STRAND formulas reduces to satisfiability of a STRAND formula; (c) there are powerful decidable fragments of STRAND, one semantically defined and one syntactically defined, where the decision procedure works by combining the theory of MSO over trees and the quantifier-free theory of the underlying data-logic. We demonstrate the effectiveness and practicality of the logic by checking verification conditions generated in proving properties of several heap-manipulating programs, using a tool that combines an MSO decision procedure over trees (MONA) with an SMT solver for integer constraints (Z3).},
journal = {SIGPLAN Not.},
month = {jan},
pages = {611–622},
numpages = {12},
keywords = {automata, smt solvers, heap analysis, combining decision procedures, decidability, monadic second-order logic}
}

@article{intro_str_prog,
author = {Tateishi, Takaaki and Pistoia, Marco and Tripp, Omer},
title = {Path- and Index-Sensitive String Analysis Based on Monadic Second-Order Logic},
year = {2013},
issue_date = {October 2013},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {22},
number = {4},
issn = {1049-331X},
url = {https://doi.org/10.1145/2522920.2522926},
doi = {10.1145/2522920.2522926},
abstract = {We propose a novel technique for statically verifying the strings generated by a program. The verification is conducted by encoding the program in Monadic Second-order Logic (M2L). We use M2L to describe constraints among program variables and to abstract built-in string operations. Once we encode a program in M2L, a theorem prover for M2L, such as MONA, can automatically check if a string generated by the program satisfies a given specification, and if not, exhibit a counterexample. With this approach, we can naturally encode relationships among strings, accounting also for cases in which a program manipulates strings using indices. In addition, our string analysis is path sensitive in that it accounts for the effects of string and Boolean comparisons, as well as regular-expression matches.We have implemented our string analysis algorithm, and used it to augment an industrial security analysis for Web applications by automatically detecting and verifying sanitizers—methods that eliminate malicious patterns from untrusted strings, making these strings safe to use in security-sensitive operations. On the 8 benchmarks we analyzed, our string analyzer discovered 128 previously unknown sanitizers, compared to 71 sanitizers detected by a previously presented string analysis.},
journal = {ACM Trans. Softw. Eng. Methodol.},
month = {oct},
articleno = {33},
numpages = {33},
keywords = {String analysis, Web security, static program analysis}
}

@InProceedings{intro_par_prog,
author="Baukus, Kai
and Bensalem, Saddek
and Lakhnech, Yassine
and Stahl, Karsten",
editor="Graf, Susanne
and Schwartzbach, Michael",
title="Abstracting WS1S Systems to Verify Parameterized Networks",
booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
year="2000",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="188--203",
abstract="We present a method that allows to verify parameterized networks of finite state processes. Our method is based on three main ideas. The first one consists in modeling an infinite family of networks by a single WS1S transition system, that is, a transition system whose variables are set (2nd-order) variables and whose transitions are described in WS1S. Then, we present methods that allow to abstract a WS1S system into a finite state system that can be model-checked. Finally, in order to verify liveness properties, we present an algorithm that allows to enrich the abstract system with strong fairness conditions while preserving safety of the abstraction. We implemented our method in a tool, called pax, and applied it to several examples.",
isbn="978-3-540-46419-8"
}

@InProceedings{intro_distr_sys,
author="Klarlund, Nils
and Nielsen, Mogens
and Sunesen, Kim",
editor="Broy, Manfred
and Merz, Stephan
and Spies, Katharina",
title="A case study in verification based on trace abstractions",
booktitle="Formal Systems Specification",
year="1996",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="341--373",
abstract="In [14], we proposed a framework for the automatic verification of reactive systems. Our main tool is a decision procedure, Mona, for Monadic Second-order Logic (M2L) on finite strings. Mona translates a formula in M2L into a finite-state automaton. We show in [14] how traces, i.e. finite executions, and their abstractions can be described behaviorally. These state-less descriptions can be formulated in terms of customized temporal logic operators or idioms.",
isbn="978-3-540-49573-4"
}

@article{intro_hw_ver,
  title={Automata based symbolic reasoning in hardware verification},
  author={Basin, David and Klarlund, Nils},
  journal={Formal Methods In System Design},
  volume={13},
  number={3},
  pages={253--286},
  year={1998},
  publisher={Boston, USA: Kluwer Academic Publishers, 1992-}
}

@InProceedings{intro_aut_synt,
author="Sandholm, Anders
and Schwartzbach, Michael I.",
editor="Astesiano, Egidio",
title="Distributed safety controllers for web services",
booktitle="Fundamental Approaches to Software Engineering",
year="1998",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="270--284",
abstract="We show how to use high-level synchronization constraints, written in a version of monadic second-order logic on finite strings, to synthesize safety controllers for interactive web services. We improve on the na{\"I}ve runtime model to avoid state-space explosions and to increase the flow capacities of services.",
isbn="978-3-540-69723-7"
}


@article{intro_symb_lib,
author = {D'Antoni, Loris and Veanes, Margus},
title = {Minimization of Symbolic Automata},
year = {2014},
issue_date = {January 2014},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {49},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/2578855.2535849},
doi = {10.1145/2578855.2535849},
abstract = {Symbolic Automata extend classical automata by using symbolic alphabets instead of finite ones. Most of the classical automata algorithms rely on the alphabet being finite, and generalizing them to the symbolic setting is not a trivial task. In this paper we study the problem of minimizing symbolic automata. We formally define and prove the basic properties of minimality in the symbolic setting, and lift classical minimization algorithms (Huffman-Moore's and Hopcroft's algorithms) to symbolic automata. While Hopcroft's algorithm is the fastest known algorithm for DFA minimization, we show how, in the presence of symbolic alphabets, it can incur an exponential blowup. To address this issue, we introduce a new algorithm that fully benefits from the symbolic representation of the alphabet and does not suffer from the exponential blowup. We provide comprehensive performance evaluation of all the algorithms over large benchmarks and against existing state-of-the-art implementations. The experiments show how the new symbolic algorithm is faster than previous implementations.},
journal = {SIGPLAN Not.},
month = {jan},
pages = {541–553},
numpages = {13},
keywords = {minimization, symbolic automata}
}

@InProceedings{intro_j_mosel,
author="Topnik, Christian
and Wilhelm, Eva
and Margaria, Tiziana
and Steffen, Bernhard",
editor="Valmari, Antti",
title="jMosel: A Stand-Alone Tool and jABC Plugin for M2L(Str)",
booktitle="Model Checking Software",
year="2006",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="293--298",
abstract="jMosel is a tool-set for the analysis and verification of linear parametric systems in monadic second-order logic on strings. In this paper we give a short introduction to the underlying concepts, as well as an overview of the implementation and the usage of jMosel.",
isbn="978-3-540-33103-2"
}

@InProceedings{intro_coalg,
  author =	{Dmitriy Traytel},
  title =	{{A Coalgebraic Decision Procedure for WS1S}},
  booktitle =	{24th EACSL Annual Conference on Computer Science Logic (CSL 2015)},
  pages =	{487--503},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-939897-90-3},
  ISSN =	{1868-8969},
  year =	{2015},
  volume =	{41},
  editor =	{Stephan Kreutzer},
  publisher =	{Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{http://drops.dagstuhl.de/opus/volltexte/2015/5433},
  URN =		{urn:nbn:de:0030-drops-54335},
  doi =		{10.4230/LIPIcs.CSL.2015.487},
  annote =	{Keywords: WS1S, decision procedure, coalgebra, Brzozowski derivatives, Isabelle}
}